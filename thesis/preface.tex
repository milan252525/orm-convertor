\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Modern software systems are subject to continuous evolution driven by shifting user requirements. These changes often affect not only application logic but also the structure of the underlying data and the queries executed over it. Consequently, developers must adapt the data-access code in response to evolving schemas, altered query workloads, or even complete changes of the underlying database management system (\acrshort{dbms}). In the worst-case scenario, such changes require data migration across \acrshort{dbms} platforms and necessitate corresponding adaptations at the application level -- particularly in the mapping and querying logic embedded in Object-Relational Mapping (\acrshort{orm}) frameworks.

While the \acrshort{dbms} side of the problem has received considerable attention -- with numerous academic and commercial solutions~\cite{mm_evocat,mm_quecat,mm_evoque} for data migration, query rewriting, and query synchronization -- less effort has been directed toward managing the consequences of such changes on application code. Existing approaches~\cite{TODO} support, for example, the rewriting of \acrshort{sql} queries for target \acrshort{dbms}(s) or synchronization within a logical data model. However, adapting the application-side \acrshort{orm} layers (entity mappings, repository classes, query logic) remains a largely manual and error-prone process. This gap becomes especially critical when the original \acrshort{orm} framework, once optimal for a given workload, becomes inefficient or incompatible due to backend changes. In such cases, memory overhead, runtime performance, or even functional compatibility can be severely affected.

On the application side, the complexity is further amplified by the diversity of available \acrshort{orm} frameworks. Each framework offers different abstractions, feature sets, performance characteristics, and support for advanced mapping patterns. Developers typically commit to a single \acrshort{orm} framework, which can result in suboptimal performance if the selected framework does not align well with specific query workloads or with the target \acrshort{dbms}. In many scenarios, a hybrid approach -- utilizing different \acrshort{orm} frameworks for disjoint query subsets -- could yield significantly better runtime and memory efficiency.

Large language models (\acrshort{llm}(s)) have recently been explored~\cite{TODO} for translating between \acrshort{orm} frameworks. While promising, current \acrshort{llm}-based solutions remain limited in practice: translations may be incomplete, semantically incorrect, or based on deprecated or insecure libraries. More critically, \acrshort{llm}(s) do not support optimization objectives: they lack mechanisms to reason about execution cost or to recommend optimal target \acrshort{orm} configurations under resource constraints (e.g., maximum memory usage per query or across a query workload).

In this thesis, we aim to achieve the following goals:
\begin{itemize}
    \item Analyze and compare selected .NET \acrshort{orm} frameworks based on their features and runtime performance.
    \item Design a unified abstraction for entities, mapping configurations, and queries to enable translation.
    \item Develop algorithms to support automated migration of entity and repository classes across different frameworks.
    \item Propose an optimization framework capable of automatically recommending the most efficient \acrshort{orm} framework, or combination of frameworks, for a given set of queries and resource constraints.
    \item Implement a prototype translation tool to demonstrate the feasibility and effectiveness of the proposed concepts.
\end{itemize}

\paragraph{Outline} In Chapter~\ref{chapter:ormcomparison} important concepts in the area of database queries and \acrshort{orm} functionality are explored. Seven frameworks are further selected for analytical comparison of their distribution, community support, and technical aspects. To demonstrate different query operations, twenty-three queries are formulated and implemented for each framework in the form of unit tests. Performance evaluation based on these queries explores execution time and memory allocation.

Chapter~\ref{chapter:core_concepts} identifies similarities of approaches to configuration by different frameworks. It builds upon them by introducing the process of translation across frameworks through an intermediate representation. An idea of an automatic advisor is presented, leveraging the translation to recommend the most performant \acrshort{orm} for a query.

Analysis from the first chapter is leveraged to shape an intermediate representation for entity classes and mapping configurations in Chapter~\ref{chapter:entity_translation}. The chapter further explores entity translation by proposing a series of interfaces and algorithms to be used in the process. Chapter~\ref{chapter:query_translation} follows by introducing a set of abstract instructions for the process of translating repository classes with query methods. Both translation processes are described in detail and illustrated by algorithms.

The concept of advisor is explored in Chapter~\ref{chapter:advisor}. It introduces an optimization module that selects the most suitable framework(s) for executing a query workload under given constraints. The selection task is formulated as an instance of Integer Linear Programming problem. The translation process is used to generate query equivalents across all target frameworks, which are then evaluated in a what-if analysis to collect empirical performance data. These measurements form the basis for the final optimization and framework recommendation.

Chapter~\ref{chapter:architecture} describes the implementation of a prototype translation tool supporting Dapper, NHibernate, and Entity Framework Core. The overall architecture is outlined, followed by an overview of the used technologies and design patterns. The application interface is demonstrated and instructions for deployment are provided. Finally, the chapter explores possible directions for future expansion.

Chapter~\ref{chapter:related_work} reviews existing research on \acrshort{orm} performance and optimization strategies. Related approaches are also explored on the side of \acrshort{dbms}(s) and in other adjacent areas such as code translation and query generation.
