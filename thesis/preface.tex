\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Modern software systems are subject to continuous evolution driven by shifting user requirements. These changes often affect not only application logic but also the structure of the underlying data and the queries executed over it. Consequently, developers must adapt the data-access code in response to evolving schemas, altered query workloads, or even complete changes of the underlying database management system (\acrshort{dbms}). In the worst-case scenario, such changes require data migration across \acrshort{dbms} platforms and necessitate corresponding adaptations at the application level -- particularly in the mapping and querying logic embedded in Object-Relational Mapping (\acrshort{orm}) frameworks.

While the \acrshort{dbms} side of the problem has received considerable attention -- with numerous academic and commercial solutions~\cite{mm_evocat,mm_quecat,mm_evoque} for data migration, query rewriting, and query synchronization -- less effort has been directed toward managing the consequences of such changes on application code. Existing approaches~\cite{DBLP:journals/vldb/KatsogiannisMeimarakisK23} support, for example, the rewriting of \acrshort{sql} queries for target \acrshort{dbms}(s) or synchronization within a logical data model. However, adapting the application-side \acrshort{orm} layers (entity mappings, repository classes, query logic) remains a largely manual and error-prone process. This gap becomes especially critical when the original \acrshort{orm} framework, once optimal for a given workload, becomes inefficient or incompatible due to backend changes. In such cases, memory overhead, runtime performance, or even functional compatibility can be severely affected.

On the application side, the complexity is further amplified by the diversity of available \acrshort{orm} frameworks. Each framework offers different abstractions, feature sets, performance characteristics, and support for advanced mapping patterns. Developers typically commit to a single \acrshort{orm} framework, which can result in suboptimal performance if the selected framework does not align well with specific query workloads or with the target \acrshort{dbms}. In many scenarios, a hybrid approach -- utilizing different \acrshort{orm} frameworks for disjoint query subsets -- could yield significantly better runtime and memory efficiency.

Large language models (\acrshort{llm}(s)) have recently been explored for various data management tasks~\cite{DBLP:journals/pvldb/FernandezEFKT23,DBLP:journals/vldb/KatsogiannisMeimarakisK23}. While promising, current \acrshort{llm}-based solutions remain limited in practice: translations of queries may be incomplete, semantically incorrect, or based on deprecated or insecure libraries. More critically, \acrshort{llm}(s) do not support optimization objectives: they lack mechanisms to reason about execution cost or to recommend optimal target \acrshort{orm} configurations under resource constraints (e.g., maximum memory usage per query or across a query workload).

In this thesis, we aim to achieve the following goals:
\begin{itemize}
    \item Analyze and compare selected .NET \acrshort{orm} frameworks based on their features and runtime performance.
    \item Design a unified abstraction for entities, mapping configurations, and queries to enable translation.
    \item Develop algorithms to support automated migration of entity and repository classes across different frameworks.
    \item Propose an optimization framework capable of automatically recommending the most efficient \acrshort{orm} framework, or combination of frameworks, for a given set of queries and resource constraints.
    \item Implement a prototype translation tool to demonstrate the feasibility and effectiveness of the proposed concepts.
\end{itemize}

\paragraph{Outline} This thesis is structured as follows: Chapter~\ref{chapter:ormcomparison} introduces key concepts in database querying and \acrshort{orm} frameworks, followed by a comparative analysis of selected frameworks and a performance evaluation using representative queries. Chapter~\ref{chapter:core_concepts} builds on identified similarities to lay the foundation for cross-framework translation. Chapters~\ref{chapter:entity_translation} and~\ref{chapter:query_translation} propose a unified abstract representation for entity classes, mapping, and queries, along with algorithms supporting the translation. Chapter~\ref{chapter:advisor} describes an optimization advisor that leverages this translation to recommend optimal frameworks under given constraints. Chapter~\ref{chapter:architecture} outlines the design and implementation of the prototype tool. Finally, Chapter~\ref{chapter:related_work} surveys related research on ORM and database optimization, and the thesis concludes with a summary and directions for future work.
