\section{Feature comparison}
We will first introduce the methodology of our comparison, deciding what properties and information to look for. Then we will follow with an overview of each framework, finishing with an overall comparison.

We will start with gathering sources for each ORM, that includes links to documentation, repository, and a NuGet distribution. We will continue with a brief introduction, mainly based on what each framework's documentation or repository README file promises. We will follow with distribution, licensing, and version info. To get an idea of relevancy, we will check development cycles, community forums, and tool support. Then we will move onto more technical areas. We are interested in database system support and configuration, as well as how each ORM handles entity mapping and various aspects of database operations. And finally, we will compare our findings with initial promises and discuss best use cases.

When mentioning supported .NET versions, we will only list versions specifically targeted by the package. But as we have already discussed, .NET packages are usually backward and forward compatible. And the .NET Standard allows targeting both .NET Framework and Core.



\subsection{Dapper}\label{sec:feat_dapper}

Dapper~\cite{Dapper,DapperRepo} is an open-source micro ORM framework, originally developed by the team at Stack Overflow. It was created in response to the inefficiencies observed with LINQ to SQL -- an ORM that preceded the Entity Framework -- particularly under increasing traffic loads. Designed for performance and simplicity, Dapper functions as a lightweight wrapper around ADO.NET\footnote{\url{https://learn.microsoft.com/en-gb/dotnet/framework/data/adonet/}}, extending the \texttt{DbConnection} object with a set of additional methods to facilitate object mapping. Its primary focus lies in mapping SQL query results to .NET objects, and it does not offer built-in support for modelling relationships or managing database schemas.

The core strength of Dapper lies in its minimal abstraction and high execution speed. Developers retain full control over SQL queries, which allows precise use of SQL dialect features specific to a given database system. Dapper is compatible with all database engines supported by ADO.NET, including Microsoft SQL Server\footnote{\url{https://www.microsoft.com/en-gb/sql-server}}, Oracle\footnote{\url{https://www.oracle.com/database/}}, PostgreSQL\footnote{\url{https://www.postgresql.org/}}, and SQLite\footnote{\url{https://sqlite.org/}}. However, it delegates schema management entirely to the developer, as it does not provide mechanisms for schema versioning or migrations. Consequently, any changes to the database schema must be manually reflected in the SQL queries and the corresponding C\# entities.

Entity mapping in Dapper is handled by matching the names of query result columns with the properties of a specified .NET class. Only exact name matches are recognized, and aliases or naming conventions are not supported without relying on unofficial extensions. Relationships between entities are not automatically resolved, though the framework offers helper methods that enable manual mapping of joined queries using lambda expressions. This process still entails a non-negligible performance overhead and potential duplication, making it a practical but suboptimal alternative to proper relationship management. Moreover, Dapper does not support collection mapping or advanced data format serialization such as JSON or XML, unless the underlying SQL engine supports it natively and the developer writes custom SQL logic to handle it.

\begin{example}
\small
This code example\cite{DapperRepo} showcases an entity and a query returning one instance. Properties are matched and filled by names, the rest remain empty.

\begin{lstlisting}[language=CSharp]
public class Dog
{
    public int? Age { get; set; }
    public Guid Id { get; set; }
    public string Name { get; set; }
    public float? Weight { get; set; }

    public int IgnoredProperty { get { return 1; } }
}

var guid = Guid.NewGuid();
var dog = connection.Query<Dog>("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });
\end{lstlisting}
\qed
\end{example}

\begin{example}
\small
In this example, each post is connected to its owner. The lambda function in \texttt{Query} methods specifies how to connect the entities. Users are likely duplicated for each post. Overall, this is just a simplification of manual handling of the data, and overhead is still present. Real use cases could be more complex and inefficient.

\begin{lstlisting}[language=CSharp]
var sql =
@"select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id";

var data = connection.Query<Post, User, Post>(
    sql, (post, user) => { post.Owner = user; return post;});
var post = data.First();
\end{lstlisting}
\qed
\end{example}

Dapper does not include capabilities such as change tracking, data seeding, or query logging. Batch operations are supported natively, while bulk operations require the use of a commercial extension (Dapper Plus)\footnote{\url{https://dapper-plus.net/}}. Transaction handling is available indirectly through ADO.NET or via community-supported extensions. All major methods have asynchronous counterparts, ensuring compatibility with modern asynchronous programming models in .NET. Despite the lack of official development tools, Dapper benefits from a variety of extensions, both official and community-driven. Notable examples include \texttt{Dapper.SqlBuilder}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder}} for SQL generation, \texttt{Dapper.Rainbow}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.Rainbow}} for simplified CRUD operations, and \texttt{Dapper.EntityFramework}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.EntityFramework}} for integrating with Entity Framework -- although the latter remains largely undocumented.

The project is distributed under the Apache 2.0 License\footnote{\url{https://github.com/DapperLib/Dapper/blob/main/License.txt}} and is freely available via GitHub\footnote{\url{https://github.com/DapperLib/Dapper}} and NuGet\footnote{\url{https://www.nuget.org/packages/dapper/}}. As of the latest release (version 2.1.66 in February 2025), Dapper has amassed over 395 million total downloads, with 120 million downloads in the past year alone\footnote{\url{TODO...}}. While the release cycle is not fixed, updates follow semantic versioning and are typically introduced in response to patches or new feature demands. The framework supports multiple .NET versions, including .NET Framework, .NET Standard, and .NET~8.

In terms of community support, Dapper exhibits a healthy level of maintenance with active issue tracking and contributions. Although responses to GitHub issues may be delayed, many questions receive attention either from maintainers or the broader community, including the original authors. Documentation is primarily hosted on an external website, Learn Dapper\footnote{\url{https://www.learndapper.com/}}, which is maintained by a sponsor responsible for developing the commercial extension Dapper Plus.

\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: Dapper}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{Dapper} \\
\midrule
\textbf{Type} & Micro ORM for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free; Dapper Plus extension costs \$999/year/developer \\
\textbf{Sources} & \url{https://github.com/DapperLib/Dapper}, \url{https://www.nuget.org/packages/Dapper}, \url{https://www.learndapper.com} \\
\textbf{Latest version} & 2.1.66 (February 2025) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard, .NET 8 \\
\textbf{ORM features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw SQL; any dialect via ADO.NET; no LINQ support \\
\textbf{Mapping} & Maps result columns to entity properties by exact name; no aliases or conventions \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in DB; SQL must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Not supported \\
\textbf{Transactions} & Supported via ADO.NET; extensions available \\
\textbf{Bulk operations} & Requires paid extension \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & Entity mapping cached internally; no data caching \\
\textbf{Community} & Maintained actively on GitHub; many questions on Stack Overflow, often answered by the author \\
\textbf{Documentation} & External site (Learn Dapper), maintained by extension sponsor; repository includes tests and examples \\
\textbf{Extensions (official)} & Dapper.SqlBuilder, Dapper.Rainbow, Dapper.EntityFramework \\
\textbf{Extensions (community)} & Dapper Plus (paid), Dapper.Transaction \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & All ADO.NET-compatible DBs: SQL Server, Oracle, SQLite, PostgreSQL, etc. \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full SQL control \\
\bottomrule
\end{tabular}
\end{table}

\subsection{PetaPoco}\label{sec:feat_petapoco}

PetaPoco\cite{PetaPoco} is the second chosen micro ORM. Although it changed recently --- it used to have a single-file code base with no dependencies. It is focused on performance and simplicity. Internally it uses ADO.NET like Dapper, yet it provides its own abstractions over it. The framework is configurable through a builder, resulting in \texttt{IDatabase} interface, on which methods are called. With a focus on mapping query results to objects, it does not provide any support for relationships. It provides full control over SQL with an inbuilt SQL builder to make composing it easier. 

Its small feature set and zero dependencies enable compatibility with a wide selection of database systems, including Microsoft SQL Server, MS Access\footnote{\url{https://support.microsoft.com/en-us/access}}, SQLite, MySQL\footnote{\url{https://www.mysql.com/}}, MariaDB\footnote{\url{https://mariadb.org/}}, and Oracle. Schema management is left to the developer. Templates for entity generation out of a database schema were provided, but were deprecated in the last major version.

Entity mapping supports automatic configuration through naming conventions, such as pluralizing property names to match database columns. A limited set of mapping attributes is offered. These can be used to map table and column names, primary keys, and ignore class properties. Like Dapper, it does not automatically handle relationships but provides helper methods for manual JOINs management.

\begin{example}
\small
In the following example, the table name and primary key are explicitly defined using attributes, while other properties rely on automatic mapping. The use of the SQL query builder is demonstrated. The projection and source table components in the query builder can be omitted when they can be inferred from the source entity.

\begin{lstlisting}[language=CSharp]
using PetaPoco;

[TableName("Sales.OrderLines")]
[PrimaryKey("OrderLineID")]
public class OrderLine
{
    public int OrderID { get; set; }
    public int OrderLineID { get; set; }
    public decimal? UnitPrice { get; set; }
}

decimal unitPrice = 25m;
var orderLines = db.Fetch<OrderLine>(
    Sql.Builder.Where("UnitPrice = @0", unitPrice)
);
\end{lstlisting}
\qed
\end{example}

No support for advanced data formats of collections is provided, with the exception of writing native SQL that can work with these structures. LINQ is not supported. Unofficial extension \texttt{StaTypPocoQueries.PetaPoco}\footnote{\url{https://github.com/asherber/StaTypPocoQueries.PetaPoco}} provides result modification methods such as \texttt{First}, \texttt{Single}, \texttt{Page}, and \texttt{Delete} with some selection capabilities. For data manipulation operations (DML), strongly-typed methods like \texttt{Insert}, \texttt{Save}, \texttt{Update}, and \texttt{Delete} are provided. 

Queries executed by the framework can be inspected during debugging. Transactions are supported, including nested transactions if the underlying database system allows. However, bulk operations are not available. Asynchronous versions of all methods are also provided. Advanced capabilities such as versioning, change tracking, and data seeding are not provided. The only notable extension is an unofficial \texttt{PetaPoco.SqlKata}\footnote{\url{https://github.com/asherber/PetaPoco.SqlKata}}, which is a more extensive SQL builder than the native one.

The library is distributed under the Apache 2.0 License\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/blob/development/LICENSE.txt}} and is open-sourced on GitHub\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco}} and NuGet\footnote{\url{https://www.nuget.org/packages/PetaPoco.Compiled/}}. PetaPoco was downloaded 1.3 million times in total, with half a million in the last year. PetaPoco has been stagnating on major version 6 (6.0.683 in September 2024) for the past few years, with minor patches being done every few months in response to security patches or new feature demands. The library targets .NET Framework and Standard.

This ORM does not benefit from extensive community support, with the only extensive source of information being its GitHub wiki\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/wiki}}. Integration tests for most database systems are available and could be used for reference.


\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: PetaPoco}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{PetaPoco} \\
\midrule
\textbf{Type} & Micro ORM for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://github.com/CollaboratingPlatypus/PetaPoco}, \url{https://www.nuget.org/packages/PetaPoco.Compiled}  \\
\textbf{Latest version} & 6.0.683 (September 2024) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard \\
\textbf{ORM features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw SQL; wide DB support; limited LINQ through extension \\
\textbf{Mapping} & Maps automatically by exact name; conventions and some attributed available \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in DB; SQL must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Accessible while debugging \\
\textbf{Transactions} & Supported; with nesting \\
\textbf{Bulk operations} & Not supported \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & No caching \\
\textbf{Community} & Maintained actively on GitHub; questions and issues not frequently responded to \\
\textbf{Documentation} & GitHub wiki; repository includes integration and unit tests\\
\textbf{Extensions (official)} & None \\
\textbf{Extensions (community)} & PetaPoco.SqlKata, StaTypPocoQueries.PetaPoco \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & Microsoft SQL Server, MS Access, SQLite, MySQL, MariaDB, Oracle, etc. \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full SQL control \\
\bottomrule
\end{tabular}
\end{table}



\subsection{RepoDB}
RepoDB~\cite{RepoDB, RepoDBRepo} is an ORM for .NET bridging the gap between micro and macro ORMs. It supposedly focuses on improving the developer experience, while maintaining the speed of macro ORMs. It requires only a connection string and should work "out of the box". Developed by Michael Camara Pendon, it is one of the more recent libraries, starting development in 2018. It provides a set of extension methods over \texttt{Microsoft.Data.SqlClient.SqlConnection} object. 

The core package supports any database system through ADO.NET, limiting querying through raw SQL. To utilize strongly typed queries, database-specific extension package is required. The developer can select from Microsoft SQL Server, SQLite, MySQL, and PostgreSQL. Schema management or entity generation is not offered. Automatic entity mapping to a result can be extended using property and class attributes or a fluent mapping interface. Relationship mapping is not supported, an interface for querying multiple results at once can be utilized. Raw join SQL query with manual handling is another option.

\begin{example}
\small
In the example\cite{RepoDB} below, the fluent mapping interface can be seen on a Customer entity. The main advantages here are separation from the entity and more programmatic configuration.

\begin{lstlisting}[language=CSharp]
FluentMapper
.Entity<Customer>()
.Table("[sales].[Customer]")
.Primary(e => e.Id)
.Column(e => e.FirstName, "[FName]")
.DbType(e => e.DateOfBirth, DbType.DateTime2);
\end{lstlisting}
\qed
\end{example}

The main focus of RepoDB is abstracting SQL. However, LINQ is not supported, and queries have to be performed through one of the following options. The main interface is type-safe expressions. As an example, \lstinline{connection.Query<Customer>(e => e.Id == 25)} queries one customer by id. The second option is QueryField and QueryGroup objects. As you can see in \lstinline{connection.Query<Customer>(new QueryField("Id", Operation.Equal, 25))}, this option is not type-safe, but should be more expressive as operator support for the first option is limited. In addition, there are more provided functions over the connection, such as \texttt{Sum}, \texttt{Max}, \texttt{Exists} functions. Data manipulation is possible using \texttt{Insert}, \texttt{Update} and \texttt{Delete} functions. Both batch and bulk operations are supported, though the latter only for Microsoft SQL Server and PostgreSQL.

Transactions are supported through ADO.NET. Application-level cache is supported in-memory, with options for custom providers. Database schema and queries are also cached, speeding up subsequent queries. The library offers a wide variety of interfaces for extension. One example can be query tracing and logging, which is provided by default but can be easily added. While the library provides asynchronous methods, there is no mention of them in the documentation. More advanced features such as change tracking, data seeding, or migration support are not provided. The ORM also focuses on providing the user with the implementation of common repository and unit of work patterns.

The project is open-source and distributed under Apache 2.0 license\footnote{\url{https://github.com/mikependon/RepoDB/blob/master/LICENSE.txt}} on GitHub\footnote{\url{https://github.com/mikependon/RepoDB}} and NuGet\footnote{\url{https://www.nuget.org/packages/repodb}}. With the latest version 1.13.1 released in March 2023, the updates are infrequent. The development is currently paused as per the author's comment\cite{PendonRepoDBComment}. The project has 1.6 million total downloads, half a million of those gained in the past year. .NET versions 7 and Standard are targeted. The documentation is hosted on a separate website\cite{RepoDB}. It provides several tutorials and widely describes available classes and APIs. However, it mostly reads as developer documentation; contextual explanations and longer examples are missing. Missing examples can be substituted by extensive unit and integration tests available in the repository. No extensions are provided, except those for specific database systems we have already discussed.


\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: RepoDB}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{RepoDB} \\
\midrule
\textbf{Type} & ORM for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://repodb.net/}, \url{https://github.com/mikependon/RepoDB}, \url{https://www.nuget.org/packages/repodb}  \\
\textbf{Latest version} & 1.13.1  (March 2023) \\
\textbf{Supported .NET} & .NET Standard, .NET 7 \\
\textbf{ORM features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Limited lambda expression support, QueryField and QueryGroup objects \\
\textbf{Mapping} & Attributes and fluent interface \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in DB; queries must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Extensible tracing interface; must be implemented \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Supported for Microsoft SQL and PostgreSQL \\
\textbf{Async support} & Supported, undocumented \\
\textbf{Caching} & Application-level caching \\
\textbf{Community} & Maintained on GitHub; questions and issues responded to; development currently paused \\
\textbf{Documentation} & Separate website; repository includes integration and unit tests\\
\textbf{Extensions (official)} & Database support extensions \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & Microsoft SQL Server, SQLite, MySQL, and PostgreSQL \\
\textbf{Ideal use cases} & Simple applications, beginner developers, performance-dependent applications possible \\
\bottomrule
\end{tabular}
\end{table}


\subsection{LINQ to DB}

LINQ to DB \cite{linq2db, linq2dbRepo}, alternatively linq2db, is an ORM that focuses primarily on offering a type-safe layer above SQL through LINQ. Statically typed, compiler-checked queries are a huge benefit for bigger projects and allow easier refactoring. It supports extensive entity and relationship mapping and should offer the best performance in terms of querying through LINQ. Relative to that focus, it does not offer features expected from full-fledged macro ORMs. There is no change tracking or caching with this framework.

LINQ to DB is compatible with a big range of database systems, for example, Microsoft SQL Server, MySQL, Oracle, PostgreSQL, MS Access, SQLite, and even less common ones like SAP HANA\footnote{\url{https://www.sap.com/products/data-cloud/hana/what-is-sap-hana.html}}, ClickHouse\footnote{\url{https://clickhouse.com/}}, and more. Database schema must be handled by the developer, but entity generation from the database is available. Configuration is fairly simple through the \texttt{DataConnection} object. This object can be inherited from, allowing us to configure a wide set of options, including entity mapping. Mapping can be done using fluent methods using the aforementioned object. Another option is attributes on the entity class and properties. Convention-based and automatic mapping is also an option. All multiplicities of relationships are configurable, although the documentation provides limited information on this topic. 

\begin{example}
\small
This example demonstrates the mapping of one-to-many relationships. Collection on the parent entity is referenced, along with references to primary and foreign keys in the relationship, and finally nullability.

\begin{lstlisting}[language=CSharp]
builder.Entity<OrderLine>()
    .HasSchemaName("Sales")
    .HasTableName("OrderLines");

builder.Entity<Order>()
    .HasSchemaName("Sales")
    .HasTableName("Orders")
    .HasPrimaryKey(x => x.OrderID)
    .Association(o => o.OrderLines, o => o.OrderID, ol => ol.OrderID, canBeNull: false);
\end{lstlisting}

\small With the mapping defined, querying the parent entity along with its associated child entities becomes straightforward. The example below demonstrates eager loading of related entities into a collection.

\begin{lstlisting}[language=CSharp]
var order = db.Orders
    .LoadWith(o => o.OrderLines)
    .Single(o => o.OrderID == 530);
\end{lstlisting}
\qed
\end{example}

While the LINQ support is extensive, querying into data types like JSON or XML is not supported. 
Database can be manipulated through exposed DDL methods like \texttt{CreateTable} and \texttt{DropTable}, but documentation provides no explanation. Data modification is possible through \texttt{Insert}, \texttt{Update} and \texttt{Delete} methods. Bulk data operations are available for selected database systems.
Advanced SQL constructs like transactions, CTE (common table expressions), \texttt{MERGE}, and window analytic functions are supported. Of course, any raw SQL can be executed too, but it is not the concern of this ORM. Asynchronous variants of all methods are exposed.

Some additional tooling is provided. Scaffolding database schema to generate entities and mapping is possible with a CLI tool. The library offers extendibility through exposed interceptor interfaces, which allow modifying behaviour in different stages of querying. Support for profiling using MiniProfiler\footnote{\url{https://github.com/MiniProfiler/dotnet}} is also explicitly provided and described.
LINQ to DB can be used alongside Entity Framework Core to extend its LINQ to SQL translation capabilities. This is enabled using an official extension built into this library.

The ORM is open-source and provided under the MIT license\footnote{\url{https://github.com/linq2db/linq2db/blob/master/MIT-LICENSE.txt}}. It is distributed via GitHub\footnote{\url{https://github.com/linq2db/linq2db}} and NuGet\footnote{\url{https://www.nuget.org/packages/linq2db}}. The last released version is 5.4.1 in April 2024, although major version 6 is currently being released under previews. The package was downloaded 14 million times in total, with almost 5 million downloads this year. Project issues receive attention from contributors and are resolved relatively quickly. Documentation is provided on a separate page; it is quite extensive and covers a lot of areas. Examples along with tests are available in the repository. The framework supports multiple .NET versions, including .NET Framework, .NET Standard, and .NET 6.

\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: LINQ to DB}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{LINQ to DB} \\
\midrule
\textbf{Type} & ORM for .NET \\
\textbf{License} & MIT \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://linq2db.github.io/index.html}, \url{https://github.com/linq2db/linq2db}, \url{https://www.nuget.org/packages/linq2db}  \\
\textbf{Latest version} & 5.4.1 (April 2024) \\
\textbf{Supported .NET} & .NET Framework, Standard, 7 \\
\textbf{ORM features} & Object and relationship mapping \\
\textbf{Query support} & Extensive LINQ support \\
\textbf{Mapping} & Attributes and fluent interface \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & No migrations; schema scaffolding from DB \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Extensible interceptors+ must be implemented \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Supported for some DBs\\
\textbf{Async support} & Supported \\
\textbf{Caching} & Not supported \\
\textbf{Community} & Maintained on GitHub; questions and issues responded to \\
\textbf{Documentation} & Separate website; repository includes tests and examples\\
\textbf{Extensions (official)} & EF Core extension \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & MiniProfiler integration, CLI scaffolding tool \\
\textbf{Supported databases} & Microsoft SQL Server, MySQL, Oracle, PostgreSQL, SQLite, MS Access, SAP HANA, ClickHouse and more  \\
\textbf{Ideal use cases} & Little SQL knowledge, any project size, complex queries \\
\bottomrule
\end{tabular}
\end{table}


\subsection{NHibernate}


NHibernate \cite{nhibernate, nhibernateRepo} started development around 2003, making it the oldest ORM on our list. Originally a port of Java Hibernate\footnote{\url{https://hibernate.org/}}, it eventually started diverging and became a community-developed .NET ORM. It is designed to be feature complete and "to relieve the developer from 95 percent of common data persistence related programming tasks" \cite{nhibernate}. 
It is highly configurable, offers various forms of entity and relationship mapping, and multiple ways to query a database. Supported database systems include Microsoft SQL Server, Oracle, MySQL, PostgreSQL, SQLite, and more.

The configuration can be done using XML files or directly in code using \texttt{NHibernate.Cfg.Configuration} object. 
Schema must be managed in the database by a developer. Exporting entities from schema is possible with a provided tool, but it is not recommended to be used in production. Migrations and versioning are not supported. Entities can be mapped with attributes or fluent configuration. Fluent mapping has been supported through an external extension FluentNHibernate\footnote{\url{https://github.com/nhibernate/fluent-nhibernate}} for a long time. In-library support was added later on, but it lacks any proper documentation. Another type of mapping, taken over from the Java world, is XML configuration files. This mapping is completely detached from ORM code, making refactoring quite complicated.


\begin{example}
\small
Let us look at two examples\cite{fluentNH} of mapping supported by NHibernate. 

\begin{lstlisting}[language=xml]
<?xml version="1.0" encoding="utf-8" ?>  
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2">  
  <class name="Cat" table="Cat">  
    <id name="Id"><generator class="identity" /></id>  
    <property name="Name">  
      <column name="Name" length="16" not-null="true" />  
    </property> 
    <property name="Sex" /> 
    <many-to-one name="Mate" />  
    <bag name="Kittens">  
      <key column="mother_id" />  
      <one-to-many class="Cat" />  
    </bag>  
  </class>  
</hibernate-mapping> 
\end{lstlisting}

The same mapping converted to fluent code is much more compact, readable, and, most importantly, statically typed. 

\begin{lstlisting}[language=CSharp]
public class CatMap : ClassMap<Cat>
{
    public CatMap()
    {
        Id(x => x.Id);
        Map(x => x.Name)
            .Length(16)
            .Not.Nullable();
        Map(x => x.Sex);
        References(x => x.Mate);
        HasMany(x => x.Kittens);
    }
}
\end{lstlisting}
\qed
\end{example}

Relationship mapping can be done into various forms of collections - list, set, hash map and all multiplicities are supported. Even class inheritance on entities can be mapped into the database. Different loading strategies are configurable. Entities can be loaded eagerly on query execution or lazily, where the loading occurs only on accessing the associated collection. To allow this, NHibernate requires every property to be \texttt{virtual},

As both NHibernate and .NET developed over the years, new forms of querying could be introduced, leading to the eventual adoption of LINQ. Predecessors to NHibernate's LINQ are still present (Criteria and QueryOver APIs), although rarely used. Those were used before the addition of lambda expressions and extension methods into the language. Another available query language is Hibernate Query Language (HQL)\footnote{\url{https://nhibernate.info/doc/nhibernate-reference/queryhql.html}}. HQL is very similar to SQL but object-oriented. It is not commonly used in the .NET world, and the queries are not statically typed as is the case with LINQ. And lastly, raw SQL queries can be executed with a lot of helper methods. SQL queries can also be stored in XML mapping files to avoid duplication. DML is fully supported along with transactions but not in bulk operations. Logging of generated SQL can be enabled. NHibernate supports XML type columns, but no querying capabilities inside it.

\begin{example}
\small
This example\cite{nhibernate} shows a difference between Criteria and LINQ queries. Criteria queries were introduced before .NET had support for LINQ. We can see the evolution from building a query object using expression builders to extension functions that retain the entity type information and statically typed lambda expressions over them. 

\begin{lstlisting}[language=CSharp]
session.CreateCriteria<Cat>()
    .Add( Expression.Like("Name", "Fritz%") )
    .Add( Expression.Between("Weight", minWeight, maxWeight) )
    .List<Cat>();

session.Query<Cat>()
    .Where(c => c.Name.StartsWith("Fritz"))
    .Where(c => c.Weight >= minWeight && c.Weight <= maxWeight)
    .ToList();
\end{lstlisting}
\qed
\end{example}

Caching is available both on session and application level. Session cache speeds up repeated queries. Application-wide cache stores separate entities and shares them across sessions. The caches are highly configurable and different providers like memcached or Redis can be utilized.
The framework offers change tracking capabilities, keeping track of all loaded entities and then saving all changes on transaction commit.

Despite being the oldest, it still receives maintenance and new features. The latest version 5.5.2 was released in July 2024. The projection is open source under GNU Lesser General Public License v2.1\footnote{\url{https://github.com/nhibernate/nhibernate-core/blob/master/LICENSE.txt}}. It is distributed on GitHub\footnote{\url{https://github.com/nhibernate}}, NuGet\footnote{\url{https://www.nuget.org/packages/nhibernate}} and SourceForge\footnote{\url{https://sourceforge.net/projects/nhibernate/}}. GitHub issues are responded to sparingly. However, the collection of questions on forums like Stack Overflow has grown large. NHibernate manages to keep up with new .NET versions, targeting Framework, Standard, and .NET 6.

The documentation is published in both PDF and HTML formats. It is comprehensive, offering detailed explanations of numerous concepts. However, many sections are outdated, referencing tools and features that are no longer available. Some areas are undocumented, like the mentioned change tracking or mapping by code.

Notable official extensions include the already mentioned FluentNHibernate, {NHibernate.Spatial}\footnote{\url{https://github.com/nhibernate/NHibernate.Spatial}} for working with spatial data and NHibernate-Search\footnote{\url{https://github.com/nhibernate/NHibernate-Search}} for full-text searching. NHibernate Profiler\footnote{\url{https://hibernatingrhinos.com/products/nhprof}} offers query profiling and analysis, but unfortunately, it is a paid unofficial tool. 

\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: NHibernate}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{NHibernate} \\
\midrule
\textbf{Type} & macro ORM for .NET \\
\textbf{License} & GNU Lesser General Public License v2.1 only \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://nhibernate.info/}, \url{https://github.com/nhibernate}, \url{https://www.nuget.org/packages/nhibernate}, \url{https://sourceforge.net/projects/nhibernate/}  \\
\textbf{Latest version} & 5.5.2 (July 2024) \\
\textbf{Supported .NET} & .NET Framework, Standard, 6 \\
\textbf{ORM features} & Full object and relationship mapping \\
\textbf{Query support} & Extensive LINQ support, HQL, Criteria and QueryOver (outdated) \\
\textbf{Mapping} & Attributes, fluent, XML files \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & No migrations; schema scaffolding from DB \\
\textbf{Change tracking} & Supported in transaction scope; undocumented \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Supported \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Not supported \\
\textbf{Async support} & Supported \\
\textbf{Caching} & Application and session level cache \\
\textbf{Community} & Maintained on GitHub; slow response to issues; wide range of questions on forums \\
\textbf{Documentation} & Separate website; HTML or PDF; Not up-to-date\\
\textbf{Extensions (official)} & FluentNHibernate, NHibernate.Spatial, NHibernate-Search  \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & Paid profiler \\
\textbf{Supported databases} & Microsoft SQL Server, Oracle, MySQL, PostgreSQL, SQLite and more  \\
\textbf{Ideal use cases} & Complex, legacy applications; Performance with caching; Complex configurability \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Entity Framework Core}

\subsection{Entity Framework 6}