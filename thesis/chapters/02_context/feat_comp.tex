\section{Feature comparison}
We will first introduce the methodology of our comparison, deciding what properties and information to look for. Then we will follow with an overview of each framework, finishing with an overall comparison.

We will start with gathering sources for each ORM, that includes links to documentation, repository, and a NuGet distribution. We will continue with a brief introduction, mainly based on what each framework's documentation or repository README file promises. We will follow with distribution, licensing, and version info. To get an idea of relevancy, we will check development cycles, community forums, and tool support. Then we will move onto more technical areas. We are interested in database system support and configuration, as well as how each ORM handles entity mapping and various aspects of database operations. And finally, we will compare our findings with initial promises and discuss best use cases.

\subsection{Dapper}\label{sec:feat_dapper}

Dapper~\cite{Dapper,DapperRepo} is an open-source micro ORM framework for .NET, originally developed by the team at Stack Overflow. It was created in response to the inefficiencies observed with LINQ to SQL -- an ORM that preceded the Entity Framework -- particularly under increasing traffic loads. Designed for performance and simplicity, Dapper functions as a lightweight wrapper around ADO.NET\footnote{\url{https://learn.microsoft.com/en-gb/dotnet/framework/data/adonet/}}, extending the \texttt{DbConnection} object with a set of additional methods to facilitate object mapping. Its primary focus lies in mapping SQL query results to .NET objects, and it does not offer built-in support for modelling relationships or managing database schemas.

The core strength of Dapper lies in its minimal abstraction and high execution speed. Developers retain full control over SQL queries, which allows precise use of SQL dialect features specific to a given database system. Dapper is compatible with all database engines supported by ADO.NET, including Microsoft SQL Server\footnote{\url{https://www.microsoft.com/en-gb/sql-server}}, Oracle\footnote{\url{https://www.oracle.com/database/}}, PostgreSQL\footnote{\url{https://www.postgresql.org/}}, and SQLite\footnote{\url{https://sqlite.org/}}. However, it delegates schema management entirely to the developer, as it does not provide mechanisms for schema versioning or migrations. Consequently, any changes to the database schema must be manually reflected in the SQL queries and the corresponding C\# entities.

Entity mapping in Dapper is handled by matching the names of query result columns with the properties of a specified .NET class. Only exact name matches are recognized, and aliases or naming conventions are not supported without relying on unofficial extensions. Relationships between entities are not automatically resolved, though the framework offers helper methods that enable manual mapping of joined queries using lambda expressions. This process still entails a non-negligible performance overhead and potential duplication, making it a practical but suboptimal alternative to proper relationship management. Moreover, Dapper does not support collection mapping or advanced data format serialization such as JSON or XML, unless the underlying SQL engine supports it natively and the developer writes custom SQL logic to handle it.

\begin{example}
\small
This code example\cite{DapperRepo} showcases an entity and a query returning one instance. Properties are matched and filled by names, the rest remain empty.

\begin{lstlisting}[language=CSharp]
public class Dog
{
    public int? Age { get; set; }
    public Guid Id { get; set; }
    public string Name { get; set; }
    public float? Weight { get; set; }

    public int IgnoredProperty { get { return 1; } }
}

var guid = Guid.NewGuid();
var dog = connection.Query<Dog>("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });
\end{lstlisting}
\qed
\end{example}

\begin{example}
\small
In this example, each post is connected to its owner. The lambda function in \texttt{Query} methods specifies how to connect the entities. Users are likely duplicated for each post. Overall, this is just a simplification of manual handling of the data, and overhead is still present. Real use cases could be more complex and inefficient.

\begin{lstlisting}[language=CSharp]
var sql =
@"select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id";

var data = connection.Query<Post, User, Post>(
    sql, (post, user) => { post.Owner = user; return post;});
var post = data.First();
\end{lstlisting}
\qed
\end{example}

Dapper does not include capabilities such as change tracking, data seeding, or query logging. Batch operations are supported natively, while bulk operations require the use of a commercial extension (Dapper Plus)\footnote{\url{https://dapper-plus.net/}}. Transaction handling is available indirectly through ADO.NET or via community-supported extensions. All major methods have asynchronous counterparts, ensuring compatibility with modern asynchronous programming models in .NET. Despite the lack of official development tools, Dapper benefits from a variety of extensions, both official and community-driven. Notable examples include \texttt{Dapper.SqlBuilder}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder}} for SQL generation, \texttt{Dapper.Rainbow}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.Rainbow}} for simplified CRUD operations, and \texttt{Dapper.EntityFramework}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.EntityFramework}} for integrating with Entity Framework -- although the latter remains largely undocumented.

The project is distributed under the Apache 2.0 License\footnote{\url{https://github.com/DapperLib/Dapper/blob/main/License.txt}} and is freely available via GitHub\footnote{\url{https://github.com/DapperLib/Dapper}} and NuGet\footnote{\url{https://www.nuget.org/packages/dapper/}}. As of the latest release (version 2.1.66 in February 2025), Dapper has amassed over 395 million total downloads, with 120 million downloads in the past year alone\footnote{\url{TODO...}}. While the release cycle is not fixed, updates follow semantic versioning and are typically introduced in response to patches or new feature demands. The framework supports multiple .NET versions, including .NET Framework, .NET Standard, and .NET~8.

In terms of community support, Dapper exhibits a healthy level of maintenance with active issue tracking and contributions. Although responses to GitHub issues may be delayed, many questions receive attention either from maintainers or the broader community, including the original authors. Documentation is primarily hosted on an external website, Learn Dapper\footnote{\url{https://www.learndapper.com/}}, which is maintained by a sponsor responsible for developing the commercial extension Dapper Plus.

\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: Dapper}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{Dapper} \\
\midrule
\textbf{Type} & Micro ORM for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free; Dapper Plus extension costs \$999/year/developer \\
\textbf{Sources} & \url{https://github.com/DapperLib/Dapper}, \url{https://www.nuget.org/packages/Dapper}, \url{https://www.learndapper.com} \\
\textbf{Latest version} & 2.1.66 (February 2025) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard, .NET 8 \\
\textbf{ORM features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw SQL; any dialect via ADO.NET; no LINQ support \\
\textbf{Mapping} & Maps result columns to entity properties by exact name; no aliases or conventions \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in DB; SQL must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Not supported \\
\textbf{Transactions} & Supported via ADO.NET; extensions available \\
\textbf{Bulk operations} & Requires paid extension \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & Entity mapping cached internally; no data caching \\
\textbf{Community} & Maintained actively on GitHub; many questions on Stack Overflow, often answered by the author \\
\textbf{Documentation} & External site (Learn Dapper), maintained by extension sponsor; repository includes tests and examples \\
\textbf{Extensions (official)} & Dapper.SqlBuilder, Dapper.Rainbow, Dapper.EntityFramework \\
\textbf{Extensions (community)} & Dapper Plus (paid), Dapper.Transaction \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & All ADO.NET-compatible DBs: SQL Server, Oracle, SQLite, PostgreSQL, etc. \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full SQL control \\
\bottomrule
\end{tabular}
\end{table}

\subsection{PetaPoco}\label{sec:feat_petapoco}

PetaPoco\cite{PetaPoco} is our second chosen micro ORM. Although it changed recently --- it used to have a single-file code base with no dependencies. It is focused on performance and simplicity. Internally it uses ADO.NET like Dapper, yet it provides its own abstractions over it. The framework is configurable through a builder, resulting in \texttt{IDatabase} interface, on which methods are called. With a focus on mapping query results to objects, it does not provide any support for relationships. It provides full control over SQL with an inbuilt SQL builder to make composing it easier. 

Its small feature set and zero dependencies enable compatibility with a wide selection of database systems, including Microsoft SQL Server, MS Access\footnote{\url{https://support.microsoft.com/en-us/access}}, SQLite, MySQL\footnote{\url{https://www.mysql.com/}}, MariaDB\footnote{\url{https://mariadb.org/}}, and Oracle. Schema management is left to the developer. Templates for entity generation out of a database schema were provided, but were deprecated in the last major version.

Entity mapping supports automatic configuration through naming conventions---such as pluralizing property names to match database columns. A limited set of mapping attributes is offered. These can be used to map table and column names, primary keys, and ignore class properties. Like Dapper, it does not automatically handle relationships but provides helper methods for manual JOINs management.

\begin{example}
\small
In the following example, the table name and primary key are explicitly defined using attributes, while other properties rely on automatic mapping. The use of the SQL query builder is demonstrated. The projection and source table components in the query builder can be omitted when they can be inferred from the source entity.

\begin{lstlisting}[language=CSharp]
using PetaPoco;

[TableName("Sales.OrderLines")]
[PrimaryKey("OrderLineID")]
public class OrderLine
{
    public int OrderID { get; set; }
    public int OrderLineID { get; set; }
    public decimal? UnitPrice { get; set; }
}

decimal unitPrice = 25m;
var orderLines = db.Fetch<OrderLine>(
    Sql.Builder.Where("UnitPrice = @0", unitPrice)
);
\end{lstlisting}
\qed
\end{example}

No support for advanced data formats of collections is provided, with the exception of writing native SQL that can work with these structures. LINQ is not supported. Unofficial extension \texttt{StaTypPocoQueries.PetaPoco}\footnote{\url{https://github.com/asherber/StaTypPocoQueries.PetaPoco}} provides result modification methods such as \texttt{First}, \texttt{Single}, \texttt{Page}, and \texttt{Delete} with some selection capabilities. For data manipulation operations (DML), strongly-typed methods like \texttt{Insert}, \texttt{Save}, \texttt{Update}, and \texttt{Delete} are provided. 

Queries executed by the framework can be inspected during debugging. Transactions are supported, including nested transactions if the underlying database system allows. However, bulk operations are not available. Asynchronous versions of all methods are also provided. Advanced capabilities such as versioning, change tracking, and data seeding are not provided. The only notable extension is an unofficial \texttt{PetaPoco.SqlKata}\footnote{\url{https://github.com/asherber/PetaPoco.SqlKata}}, which is a more extensive SQL builder than the native one.

The library is distributed under the Apache 2.0 License\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/blob/development/LICENSE.txt}} and is open-sourced on GitHub\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco}} and NuGet\footnote{\url{https://www.nuget.org/packages/PetaPoco.Compiled/}}. PetaPoco was downloaded 1.3 million times in total, with half a million in the last year. PetaPoco has been stagnating on major version 6 (6.0.683 in September 2024) for the past few years, with minor patches being done every few months in response to security patches or new feature demands. The library targets .NET Framework and Standard.

This ORM does not benefit from an extensive community support, with the only extensive source of information being its GitHub wiki\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/wiki}}. Integration tests for most database systems are available and could be used for reference.


\begin{table}[H]
\centering
\caption{Comparison overview of ORM framework: PetaPoco}
\begin{tabular}{|l|l|}
\toprule
\textbf{Property} & \textbf{PetaPoco} \\
\midrule
\textbf{Type} & Micro ORM for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://github.com/CollaboratingPlatypus/PetaPoco}, \url{https://www.nuget.org/packages/PetaPoco.Compiled}  \\
\textbf{Latest version} & 6.0.683 (September 2024) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard \\
\textbf{ORM features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw SQL; wide DB support; limited LINQ through extension \\
\textbf{Mapping} & Maps automatically by exact name; conventions and some attributed available \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in DB; SQL must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Accessible while debugging \\
\textbf{Transactions} & Supported; with nesting \\
\textbf{Bulk operations} & Not supported \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & No caching \\
\textbf{Community} & Maintained actively on GitHub; questions and issues not frequently responded to \\
\textbf{Documentation} & GitHub wiki; repository includes integration and unit tests\\
\textbf{Extensions (official)} & None \\
\textbf{Extensions (community)} & PetaPoco.SqlKata, StaTypPocoQueries.PetaPoco \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & Microsoft SQL Server, MS Access, SQLite, MySQL, MariaDB, Oracle, etc. \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full SQL control \\
\bottomrule
\end{tabular}
\end{table}



\subsection{RepoDB}

\subsection{LINQ to DB}

\subsection{NHibernate}
\subsection{EF Core}
\subsection{EF 6}