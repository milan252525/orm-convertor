\section{Feature comparison}
The process begins by gathering sources for each \acrshort{orm}, including links to documentation, repositories, and package managers. Each framework is briefly introduced, primarily based on claims made in its official documentation. This is followed by an overview of distribution channels, licensing, and versioning information. To assess relevancy, development activity, community engagement, and available tool support are reviewed. The focus then shifts to more technical aspects, such as supported database systems and configuration options, as well as how each \acrshort{orm} handles entity and relationship mapping and various aspects of database operations.

In the context of the .NET ecosystem, the focus is placed on supported versions. Therefore, only versions explicitly targeted by the package are listed. However, as previously discussed, the use of .NET Standard enables targeting both .NET Framework and .NET Core. And .NET packages typically maintain both backward and forward compatibility.

To help assess usage, download counts are considered. These figures are obtained from the respective NuGet package pages, with aggregate counts sourced from the NuGet Trends website.\footnote{\url{https://nugettrends.com/}} Yearly downloads reflect the period between 30th June 2024 and 29th June 2025.

\subsection{Dapper}
\label{sec:feat_dapper}

Dapper~\cite{Dapper,DapperRepo} is an open-source micro \acrshort{orm} framework, originally developed by the team at Stack Overflow. It was created in response to the inefficiencies observed with LINQ to SQL, a predecessor of the Entity Framework (\acrshort{ef}), particularly under increasing traffic loads. Designed for performance and simplicity, Dapper functions as a lightweight wrapper around ADO.NET,\footnote{\url{https://learn.microsoft.com/en-gb/dotnet/framework/data/adonet/}} extending the \texttt{DbConnection} object with a set of additional methods to facilitate object mapping. Its primary focus lies in mapping \acrshort{sql} query results to .NET objects, and it does not offer built-in support for modeling relationships or managing database schemas.

The core strength of Dapper lies in minimal abstraction and high execution speed. Developers retain full control over \acrshort{sql} queries, which allows precise use of \acrshort{sql} dialect features specific to a given database system. Dapper is compatible with all \acrshort{dbms}(s) supported by ADO.NET, including Microsoft SQL Server,\footnote{\url{https://www.microsoft.com/en-gb/sql-server}} Oracle,\footnote{\url{https://www.oracle.com/database/}}  PostgreSQL,\footnote{\url{https://www.postgresql.org/}} and SQLite.\footnote{\url{https://sqlite.org/}} However, it delegates schema management entirely to the developer, as it does not provide mechanisms for schema versioning or migrations. Consequently, any changes to the database schema must be manually reflected in the \acrshort{sql} queries and the corresponding C\# entities.

Entity mapping in Dapper is handled by matching the names of query result columns with the properties of a specified .NET class. Only exact name matches are recognized, and aliases or naming conventions are not supported without relying on unofficial extensions. Relationships between entities are not automatically resolved, though the framework offers helper methods that enable manual mapping of joined queries using lambda expressions. This process still entails a non-negligible performance overhead and potential duplication, making it a practical but suboptimal alternative to proper relationship management. Moreover, Dapper does not support collection mapping or advanced data format serialization such as \acrshort{json} or \acrshort{xml}, unless the underlying \acrshort{sql} engine supports it natively and the developer writes custom \acrshort{sql} logic to handle it.

\begin{example}
\small
This code example from the Dapper repository\footnote{\url{https://github.com/DapperLib/Dapper?tab=readme-ov-file\#execute-a-query-and-map-it-to-a-list-of-typed-objects}} showcases an entity and a query returning one instance. Properties are matched and filled by name, the rest remain empty.
\qed

\begin{lstlisting}[language=CSharp]
public class Dog
{
    public int? Age { get; set; }
    public Guid Id { get; set; }
    public string Name { get; set; }
    public float? Weight { get; set; }

    public int IgnoredProperty { get { return 1; } }
}

var guid = Guid.NewGuid();
var dog = connection.Query<Dog>("select Age = @Age, Id = @Id", new { Age = (int?)null, Id = guid });
\end{lstlisting}
\end{example}

\begin{example}
\small
In this example from the same repository\footnote{\url{https://github.com/DapperLib/Dapper?tab=readme-ov-file\#multi-mapping}}, each post is connected to its owner. The lambda function in \texttt{Query} methods specifies how to connect the entities. Users are likely duplicated for each post. Overall, this is just a simplification of the manual handling of the data, and overhead is still present. Real use cases could be more complex and inefficient.
\qed

\begin{lstlisting}[language=CSharp]
var sql =
@"select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id";

var data = connection.Query<Post, User, Post>(
    sql, (post, user) => { post.Owner = user; return post;});
var post = data.First();
\end{lstlisting}
\end{example}

Dapper does not include capabilities such as change tracking, data seeding, or query logging. Batch operations are supported natively, while bulk operations require the use of a commercial extension (Dapper Plus).\footnote{\url{https://dapper-plus.net/}} Transaction handling is available indirectly through ADO.NET or via community-supported extensions. All major methods have asynchronous counterparts, ensuring compatibility with modern asynchronous programming models in .NET. Despite the lack of official development tools, Dapper benefits from a variety of extensions, both official and community-driven. Notable examples include \texttt{Dapper.SqlBuilder}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder}} for SQL generation, \texttt{Dapper.Rainbow}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.Rainbow}} for simplified CRUD operations, and \texttt{Dapper.EntityFramework}\footnote{\url{https://github.com/DapperLib/Dapper/tree/main/Dapper.EntityFramework}} for integrating with Entity Framework -- although the latter remains largely undocumented.

The project is distributed under the Apache 2.0 License\footnote{\url{https://github.com/DapperLib/Dapper/blob/main/License.txt}} and is freely available via GitHub\footnote{\url{https://github.com/DapperLib/Dapper}} and NuGet\footnote{\url{https://www.nuget.org/packages/dapper/}}. As of the latest release (version 2.1.66 in February 2025), Dapper has amassed over 496 million total downloads, with 144 million downloads in the past year alone.\footnote{\url{https://nugettrends.com/packages?months=72&ids=Dapper}} While the release cycle is not fixed, updates follow semantic versioning and are typically introduced in response to patches or new feature demands. The framework supports multiple .NET versions, including .NET Framework, .NET Standard, and .NET~8.

In terms of community support, Dapper exhibits a healthy level of maintenance with active issue tracking and contributions. Although responses to GitHub issues may be delayed, many questions receive attention either from maintainers or the broader community, including the original authors. Documentation is primarily hosted on an external website, Learn Dapper,\footnote{\url{https://www.learndapper.com/}} which is maintained by a sponsor responsible for developing the commercial extension Dapper Plus. All findings are summarized in Table~\ref{tab:comp_dapper}.

\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: Dapper}
\label{tab:comp_dapper}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{Dapper} \\
\midrule
\textbf{Type} & Micro \acrshort{orm} for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free; Dapper Plus is paid extension  \\
\textbf{Sources} & \url{https://github.com/DapperLib/Dapper} \newline \url{https://www.nuget.org/packages/Dapper} \newline \url{https://www.learndapper.com} \\
\textbf{Latest version} & 2.1.66 (February 2025) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard, .NET 8 \\
\textbf{\acrshort{orm} features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw \acrshort{sql}; any dialect via ADO.NET; no \acrshort{linq} support \\
\textbf{Mapping} & Maps result columns to entity properties by exact name; no aliases or conventions \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in \acrshort{dbms}; \acrshort{sql} must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Not supported \\
\textbf{Transactions} & Supported via ADO.NET; extensions available \\
\textbf{Bulk operations} & Paid extension required \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & Entity mapping cached internally; no data caching \\
\textbf{Community} & Maintained actively on GitHub; many questions on Stack Overflow, often answered by the author \\
\textbf{Documentation} & External site (Learn Dapper), maintained by extension sponsor; repository includes tests and examples \\
\textbf{Extensions (official)} & Dapper.SqlBuilder, Dapper.Rainbow, Dapper.EntityFramework \\
\textbf{Extensions (community)} & Dapper Plus (paid), Dapper.Transaction \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & All ADO.NET-compatible \acrshort{dbms}(s), such as, e.g., SQL Server, Oracle, SQLite, PostgreSQL \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full \acrshort{sql} control \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}

\subsection{PetaPoco}
\label{sec:feat_petapoco}

PetaPoco~\cite{PetaPoco} is the second chosen micro \acrshort{orm}. Although recently changed, it previously had a single-file codebase with no external dependencies. It is focused on performance and simplicity. Internally it uses ADO.NET like Dapper, yet it provides its own abstractions over it. The framework is configurable through a builder, resulting in \texttt{IDatabase} interface, on which methods are called. With a focus on mapping query results to objects, it does not provide any support for relationships. It provides full control over \acrshort{sql} with an inbuilt \acrshort{sql} builder to make composing queries easier. 

Its small feature set and zero dependencies enable compatibility with a wide selection of database systems, including \acrshort{mssql}, \acrshort{ms} Access,\footnote{\url{https://support.microsoft.com/en-us/access}} SQLite, MySQL,\footnote{\url{https://www.mysql.com/}} MariaDB,\footnote{\url{https://mariadb.org/}} and Oracle. Schema management is left to the developer. Templates for generating entities from a database schema were provided but were deprecated in the latest major version.

Entity mapping supports automatic configuration through naming conventions, such as pluralizing property names to match database columns. A limited set of mapping attributes is offered. These can be used to map table and column names, primary keys, and ignore class properties. Like Dapper, it does not automatically handle relationships but provides helper methods for manual JOINs management.

\begin{example}
\small
In the following example, the table name and primary key are explicitly defined using attributes, while other properties rely on automatic mapping. The use of the \acrshort{sql} query builder is demonstrated. The projection and source table components in the query builder can be omitted when they can be inferred from the source entity.
\qed

\begin{lstlisting}[language=CSharp]
using PetaPoco;

[TableName("Sales.OrderLines")]
[PrimaryKey("OrderLineID")]
public class OrderLine
{
    public int OrderID { get; set; }
    public int OrderLineID { get; set; }
    public decimal? UnitPrice { get; set; }
}

decimal unitPrice = 25m;
var orderLines = db.Fetch<OrderLine>(
    Sql.Builder.Where("UnitPrice = @0", unitPrice)
);
\end{lstlisting}
\end{example}

No support for advanced data formats or collections is provided, with the exception of writing native \acrshort{sql} that can work with these structures. \acrshort{linq} is not supported. Unofficial extension \texttt{StaTypPocoQueries.PetaPoco}\footnote{\url{https://github.com/asherber/StaTypPocoQueries.PetaPoco}} provides result modification methods such as \texttt{First}, \texttt{Single}, \texttt{Page}, and \texttt{Delete} with some selection capabilities. For \textit{data manipulation language} (\acrshort{dml}) operations, strongly-typed methods like \texttt{Insert}, \texttt{Save}, \texttt{Update}, and \texttt{Delete} are provided. 

Queries executed by the framework can be inspected during debugging. Transactions are supported, including nested transactions if the underlying database system allows. However, bulk operations are not available. Asynchronous versions of all methods are provided. Advanced capabilities such as versioning, change tracking, and data seeding are not offered. The only notable extension is an unofficial \texttt{PetaPoco.SqlKata}\footnote{\url{https://github.com/asherber/PetaPoco.SqlKata}}, which is a more extensive \acrshort{sql} builder than the native one.

The library is distributed under the Apache 2.0 License\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/blob/development/LICENSE.txt}} and is open-sourced on GitHub\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco}} and NuGet.\footnote{\url{https://www.nuget.org/packages/PetaPoco.Compiled/}} PetaPoco was downloaded 1.8 million times in total, with 600 thousand in the last year.\footnote{\url{https://nugettrends.com/packages?months=72&ids=PetaPoco.Compiled}} PetaPoco has been stagnating on major version 6 (6.0.683 in September 2024) for the past few years, with minor patches being done every few months in response to security patches or new feature demands. The library targets .NET Framework and Standard.

This \acrshort{orm} does not benefit from extensive community support, with the only source of information being its GitHub wiki.\footnote{\url{https://github.com/CollaboratingPlatypus/PetaPoco/wiki}} Integration tests for most database systems are available and could be used for reference. Table~\ref{tab:comp_petapoco} presents the summarized findings.

\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: PetaPoco}
\label{tab:comp_petapoco}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{PetaPoco} \\
\midrule
\textbf{Type} & Micro \acrshort{orm} for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://github.com/CollaboratingPlatypus/PetaPoco} \newline \url{https://www.nuget.org/packages/PetaPoco.Compiled}  \\
\textbf{Latest version} & 6.0.683 (September 2024) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard \\
\textbf{\acrshort{orm} features} & Object mapping only; no relationship or collection support \\
\textbf{Query support} & Raw \acrshort{sql}; wide \acrshort{dbms} support \\
\textbf{Mapping} & Maps automatically by exact name; conventions and some attributed available \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in \acrshort{dbms}; \acrshort{sql} must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Accessible while debugging \\
\textbf{Transactions} & Supported; with nesting \\
\textbf{Bulk operations} & Not supported \\
\textbf{Async support} & Fully supported \\
\textbf{Caching} & No caching \\
\textbf{Community} & Maintained actively on GitHub; questions and issues not frequently responded to \\
\textbf{Documentation} & GitHub wiki; repository includes integration and unit tests\\
\textbf{Extensions (official)} & None \\
\textbf{Extensions (community)} & PetaPoco.SqlKata, StaTypPocoQueries.PetaPoco \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & \acrshort{mssql}, \acrshort{ms} Access, SQLite, MySQL, MariaDB, Oracle, etc. \\
\textbf{Ideal use cases} & High-performance data reading, performance bottleneck zones, apps requiring full \acrshort{sql} control \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}



\subsection{RepoDB}
RepoDB~\cite{RepoDB, RepoDBRepo} is an \acrshort{orm} bridging the gap between micro and macro \acrshort{orm}(s). It supposedly focuses on improving the developer experience, while maintaining the speed of macro \acrshort{orm}(s). It requires only a connection string and should work \textit{out of the box}. Developed by Michael Camara Pendon, it is one of the more recent libraries, starting development in 2018. It provides a set of extension methods over \texttt{Microsoft.Data.SqlClient.SqlConnection} object. 

The core package supports any database system through ADO.NET, limiting querying through raw \acrshort{sql}. To utilize strongly typed queries, database-specific extension package is required. The developer can select from \acrshort{mssql}, SQLite, MySQL, and PostgreSQL. Schema management or entity generation is not offered. Automatic entity mapping to a result can be extended using property and class attributes or a fluent mapping interface. Relationship mapping is not supported, an interface for querying multiple results at once can be utilized.

\begin{example}
\small
In this example adapted from RepoDB's documentation~\footnote{\url{https://repodb.net/mapper/fluentmapper}}, the fluent mapping interface can be seen on a \texttt{Customer} entity. The main advantages here are separation from the entity and more programmatic configuration.
\qed

\begin{lstlisting}[language=CSharp]
FluentMapper
.Entity<Customer>()
.Table("[sales].[Customer]")
.Primary(e => e.Id)
.Column(e => e.FirstName, "[FName]")
.DbType(e => e.DateOfBirth, DbType.DateTime2);
\end{lstlisting}
\end{example}

The main focus of RepoDB is abstracting \acrshort{sql}. However, \acrshort{linq} is not supported, and queries have to be performed through one of the following options. The main interface is type-safe expressions -- for example, see the following example querying one customer by id: \lstinline{connection.Query<Customer>(e => e.Id == 25)}. The second option is \texttt{QueryField} and \texttt{QueryGroup} objects. As you can see in \lstinline{connection.Query<Customer>(new QueryField("Id", Operation.Equal, 25))}, this option is not type-safe, but should be more expressive as operator support for the first option is limited. In addition, there are more provided functions over the connection, such as \texttt{Sum}, \texttt{Max}, \texttt{Exists} functions. Data manipulation is possible using \texttt{Insert}, \texttt{Update} and \texttt{Delete} functions. Both batch and bulk operations are supported, though the latter only for \acrshort{mssql} and PostgreSQL.

Transactions are handled through ADO.NET. Application-level cache is supported in-memory, with options for custom providers. Database schema and queries are also cached, speeding up subsequent queries. The library offers a wide variety of interfaces for extension. One example can be query tracing and logging, which is not provided by default but can be easily added. While the library provides asynchronous methods, there is no mention of them in the documentation. More advanced features such as change tracking, data seeding, or migration support are not provided. The \acrshort{orm} also focuses on providing the user with the implementation of common repository and unit of work patterns.

The project is open-source and distributed under Apache 2.0 license\footnote{\url{https://github.com/mikependon/RepoDB/blob/master/LICENSE.txt}} on GitHub\footnote{\url{https://github.com/mikependon/RepoDB}} and NuGet.\footnote{\url{https://www.nuget.org/packages/repodb}} With the latest version 1.13.1 released in March 2023, the updates are infrequent. The development is currently paused as per the author's comment.\footnote{\url{https://github.com/mikependon/RepoDB/issues/1200\#issuecomment-2703682584}} The project has over 1.9 million total downloads, approximately half a million of those gained in the past year.\footnote{\url{https://nugettrends.com/packages?months=72&ids=RepoDb}} .NET versions 7 and Standard are targeted. 

The documentation is hosted on a separate website.\footnote{\url{https://repodb.net/}} It provides several tutorials and widely describes available classes and \acrshort{api}(s). However, it mostly reads as developer documentation; contextual explanations and longer examples are missing. Missing examples can be substituted by extensive unit and integration tests available in the repository. No extensions are provided, except those for specific database systems already discussed. All findings are summarized in Table~\ref{tab:comp_repodb}.


\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: RepoDB}
\label{tab:comp_repodb}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{RepoDB} \\
\midrule
\textbf{Type} & \acrshort{orm} for .NET \\
\textbf{License} & Apache 2.0 \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://repodb.net/} \newline \url{https://github.com/mikependon/RepoDB} \newline \url{https://www.nuget.org/packages/repodb}  \\
\textbf{Latest version} & 1.13.1  (March 2023) \\
\textbf{Supported .NET} & .NET Standard, .NET 7 \\
\textbf{\acrshort{orm} features} & Object mapping only; no relationship  support \\
\textbf{Query support} & Limited lambda expression support, QueryField and QueryGroup objects \\
\textbf{Mapping} & Attributes and fluent interface \\
\textbf{Relationship mapping} & Not supported directly; JOINs and result splitting possible manually \\
\textbf{Schema handling} & No migrations; schema defined in \acrshort{dbms}; queries must be adjusted manually \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Extensible tracing interface; must be implemented \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Supported for \acrshort{mssql} and PostgreSQL \\
\textbf{Async support} & Supported, undocumented \\
\textbf{Caching} & Application-level caching \\
\textbf{Community} & Maintained on GitHub; questions and issues responded to; development currently paused \\
\textbf{Documentation} & Separate website; repository includes integration and unit tests\\
\textbf{Extensions (official)} & Database support extensions \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & None available \\
\textbf{Supported databases} & \acrshort{mssql}, SQLite, MySQL, and PostgreSQL \\
\textbf{Ideal use cases} & Simple applications, beginner developers, performance-dependent applications possible \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}

\subsection{LINQ to DB}
\label{section:linqToDb}

LINQ to DB~\cite{linq2db, linq2dbRepo}, alternatively linq2db, is an \acrshort{orm} that focuses primarily on offering a type-safe layer above \acrshort{sql} through \acrshort{linq}. Statically typed, compiler-checked queries are a huge benefit for bigger projects and allow easier refactoring. It supports extensive entity and relationship mapping and should offer the best performance in terms of querying through \acrshort{linq}. Relative to that focus, it does not offer features expected from full-fledged macro \acrshort{orm}(s). There is no change tracking or caching with this framework.

LINQ to DB is compatible with a big range of database systems, e.g., \acrshort{mssql}, MySQL, Oracle, PostgreSQL, \acrshort{ms} Access, SQLite, and even less common ones like SAP HANA,\footnote{\url{https://www.sap.com/products/data-cloud/hana/what-is-sap-hana.html}} ClickHouse,\footnote{\url{https://clickhouse.com/}}. Database schema must be handled by the developer, but entity generation from the database is available. Configuration is fairly simple through the \texttt{DataConnection} object. This object can be inherited from, allowing configuration of a wide set of options, including entity mapping. Mapping can be done using fluent methods using the aforementioned object. Another option is attributes on the entity class and properties. Convention-based and automatic mapping is also a possibility. All multiplicities of relationships are configurable, although the documentation provides limited information on this topic.\footnote{\url{https://linq2db.github.io/index.html\#configuration-using-mapping-attributes}}

\begin{example}
\small
This example demonstrates the mapping of one-to-many relationships. Collection on the parent entity is referenced, along with references to primary and foreign keys in the relationship, and finally nullability.

\begin{lstlisting}[language=CSharp]
builder.Entity<OrderLine>()
    .HasSchemaName("Sales")
    .HasTableName("OrderLines");

builder.Entity<Order>()
    .HasSchemaName("Sales")
    .HasTableName("Orders")
    .HasPrimaryKey(x => x.OrderID)
    .Association(o => o.OrderLines, o => o.OrderID, ol => ol.OrderID, canBeNull: false);
\end{lstlisting}

\small With the mapping defined, querying the parent entity along with its associated child entities becomes straightforward. The example below demonstrates eager loading of related entities into a collection.
\qed

\begin{lstlisting}[language=CSharp]
var order = db.Orders
    .LoadWith(o => o.OrderLines)
    .Single(o => o.OrderID == 530);
\end{lstlisting}
\end{example}

While the \acrshort{linq} support is extensive, querying into data types like \acrshort{json} or \acrshort{xml} remains unsupported. 
Database can be manipulated through exposed \acrshort{ddl} methods like \texttt{CreateTable} and \texttt{DropTable}, but the documentation provides no explanation. Data modification is possible through \texttt{Insert}, \texttt{Update} and \texttt{Delete} methods. Bulk data operations are available for selected database systems.
Advanced \acrshort{sql} constructs like transactions, common table expressions (\acrshort{cte}), \texttt{MERGE}, and window analytic functions are supported. Asynchronous variants of all methods are exposed.

Some additional tooling is provided. Scaffolding database schema to generate entities and mapping is possible with a \acrshort{cli} tool. The library offers extendibility through exposed interceptor interfaces, which allow modifying behavior in different stages of querying. Support for profiling using MiniProfiler\footnote{\url{https://github.com/MiniProfiler/dotnet}} is also explicitly provided and described.
LINQ to DB can be used alongside Entity Framework Core to extend its translation capabilities from \acrshort{linq} to \acrshort{sql}. This is enabled using an official extension built into this library.

The LINQ to DB framework is open-source and provided under the MIT license.\footnote{\url{https://github.com/linq2db/linq2db/blob/master/MIT-LICENSE.txt}} It is distributed via GitHub\footnote{\url{https://github.com/linq2db/linq2db}} and NuGet.\footnote{\url{https://www.nuget.org/packages/linq2db}} The last released version is 5.4.1 in April 2024, although major version 6 is currently being released under previews. The package was downloaded 17 million times in total, with almost 5 million downloads in the last year.\footnote{\url{https://nugettrends.com/packages?months=72&ids=linq2db}} Project issues receive attention from contributors and are resolved relatively quickly. Documentation is provided on a separate page; it is quite extensive and covers a lot of areas. Examples, along with tests, are available in the repository. The framework supports multiple .NET versions, including .NET Framework, .NET Standard, and .NET 6. A summary of the analysis is shown in Table~\ref{tab:comp_linq2db}.

\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: LINQ to DB}
\label{tab:comp_linq2db}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{LINQ to DB} \\
\midrule
\textbf{Type} & \acrshort{orm} for .NET \\
\textbf{License} & MIT \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://linq2db.github.io/index.html} \newline \url{https://github.com/linq2db/linq2db} \newline \url{https://www.nuget.org/packages/linq2db}  \\
\textbf{Latest version} & 5.4.1 (April 2024) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard, .NET 7 \\
\textbf{\acrshort{orm} features} & Object and relationship mapping \\
\textbf{Query support} & Extensive \acrshort{linq} support \\
\textbf{Mapping} & Attributes and fluent interface \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & No migrations; schema scaffolding from DB \\
\textbf{Change tracking} & Not supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Extensible interceptors must be implemented \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Supported for some \acrshort{dbms}(s)\\
\textbf{Async support} & Supported \\
\textbf{Caching} & Not supported \\
\textbf{Community} & Maintained on GitHub; questions and issues responded to \\
\textbf{Documentation} & Separate website; repository includes tests and examples\\
\textbf{Extensions (official)} & \acrshort{ef} Core extension \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & MiniProfiler integration, \acrshort{cli} scaffolding tool \\
\textbf{Supported databases} & \acrshort{mssql}, MySQL, Oracle, PostgreSQL, SQLite, \acrshort{ms} Access, SAP HANA, ClickHouse and more  \\
\textbf{Ideal use cases} & Little \acrshort{sql} knowledge, any project size, complex queries \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}


\subsection{NHibernate}
\label{section:nhibernate}

NHibernate~\cite{nhibernate, nhibernateRepo} started development around 2003, making it the oldest \acrshort{orm} on our list. Originally a port of Java Hibernate\footnote{\url{https://hibernate.org/}}, it eventually started diverging and became a community-developed .NET \acrshort{orm} framework. It is designed to be feature complete and ``to relieve the developer from 95 percent of common data persistence related programming tasks''~\cite{nhibernate}. 
It is highly configurable, offers various forms of entity and relationship mapping, and multiple ways to query a database. Supported \acrshort{dbms}(s) include, e.g.,  \acrshort{mssql}, Oracle, MySQL, PostgreSQL, SQLite.

The configuration can be done using \acrshort{xml} files or directly in code using \texttt{NHibernate.Cfg.Configuration} object. 
Schema must be managed in the \acrshort{dbms} by a developer. Exporting entities from schema is possible with a provided tool, but it is not recommended to be used in production. Migrations and versioning are not supported. Entities can be mapped with attributes or fluent configuration. Fluent mapping has been supported through an external extension FluentNHibernate\footnote{\url{https://github.com/nhibernate/fluent-nhibernate}} for a long time. In-library support was added later on, but it lacks any proper documentation. Another type of mapping, taken over from the Java world, is \acrshort{xml} configuration files. This mapping is completely detached from \acrshort{orm} code, making refactoring quite complicated.

\begin{example}
\small
Let us consider two examples of supported mapping adapted from FluentNHibernate's documentation.\footnote{\url{https://fluentnhibernate.fandom.com/wiki/Getting_started}} The first one demonstrates mapping in \acrshort{xml} format.

\begin{lstlisting}[language=xml]
<?xml version="1.0" encoding="utf-8" ?>  
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2">  
  <class name="Cat" table="Cat">  
    <id name="Id"><generator class="identity" /></id>  
    <property name="Name">  
      <column name="Name" length="16" not-null="true" />  
    </property> 
    <many-to-one name="Mate" />  
    <bag name="Kittens">  
      <key column="mother_id" />  
      <one-to-many class="Cat" />  
    </bag>  
  </class>  
</hibernate-mapping> 
\end{lstlisting}

The same mapping converted to fluent code is much more compact, readable, and, most importantly, statically typed. 
\qed

\begin{lstlisting}[language=CSharp]
public class CatMap : ClassMap<Cat>
{
    public CatMap()
    {
        Id(x => x.Id);
        Map(x => x.Name)
            .Length(16)
            .Not.Nullable();
        References(x => x.Mate);
        HasMany(x => x.Kittens);
    }
}
\end{lstlisting}
\end{example}

Relationship mapping can be done into various forms of collections, e.g., list, set, and hash map, and all multiplicities are supported. Even class inheritance on entities can be mapped into the database. Different loading strategies are configurable. Entities can be loaded eagerly on query execution or lazily, where the loading occurs only on accessing the associated collection. To allow this, NHibernate requires every property to be \texttt{virtual},

As both NHibernate and .NET developed over the years, new forms of querying could be introduced, leading to the eventual adoption of \acrshort{linq}. Predecessors to NHibernate's \acrshort{linq} are still present (Criteria and QueryOver \acrshort{api}(s)), although rarely used. Those were used before the addition of lambda expressions and extension methods into the language. Another available query language is Hibernate Query Language (\acrshort{hql}).\footnote{\url{https://nhibernate.info/doc/nhibernate-reference/queryhql.html}} \acrshort{hql} is very similar to \acrshort{sql} but object-oriented. It is not commonly used in the .NET world, and the queries are not statically typed as is the case with \acrshort{linq}. And lastly, raw \acrshort{sql} queries can be executed with a lot of helper methods. \acrshort{sql} queries can also be stored in \acrshort{xml} mapping files to avoid duplication. \acrshort{dml} is fully supported along with transactions but not in bulk operations. Logging of generated \acrshort{sql} can be enabled. NHibernate supports \acrshort{xml} type columns, but no querying capabilities inside it. NHibernate operates using a \textit{session}, an object responsible for managing interactions with the database. In typical web applications, a session is short-lived and scoped to a single \acrshort{http} request. That ensures all database operations with that request are isolated and consistent.

\begin{example}
\small
This example from NHibernate's documentation\footnote{\url{https://nhibernate.info/doc/nhibernate-reference/}} shows a difference between Criteria and \acrshort{linq} queries. Criteria queries were introduced prior to native \acrshort{linq} support in .NET. The example demonstrates the evolution from constructing query objects with expression builders to using extension methods that preserve entity type information and enable statically typed lambda expressions.
\qed

\begin{lstlisting}[language=CSharp]
session.CreateCriteria<Cat>()
    .Add(Expression.Like("Name", "Fritz%"))
    .Add(Expression.Between("Weight", minWeight, maxWeight))
    .List<Cat>();

session.Query<Cat>()
    .Where(c => c.Name.StartsWith("Fritz"))
    .Where(c => c.Weight >= minWeight && c.Weight <= maxWeight)
    .ToList();
\end{lstlisting}
\end{example}

Caching is available both on session and application levels. Session cache speeds up repeated queries. Application-wide cache stores separate entities and shares them across sessions. The caches are highly configurable and different providers like memcached\footnote{\url{https://memcached.org/}} or Redis\footnote{\url{https://redis.io/}} can be utilized.
The framework offers change tracking capabilities, keeping track of all loaded entities and then saving all changes on transaction commit.

Despite being the oldest, it still receives maintenance and new features. It was downloaded 57 million times in total, with 14 million downloads in the last year.\footnote{\url{https://nugettrends.com/packages?months=72&ids=NHibernate}} The latest version 5.5.2 was released in July 2024. The project is open source under GNU Lesser General Public License v2.1.\footnote{\url{https://github.com/nhibernate/nhibernate-core/blob/master/LICENSE.txt}} It is distributed on GitHub\footnote{\url{https://github.com/nhibernate}}, NuGet\footnote{\url{https://www.nuget.org/packages/nhibernate}} and SourceForge.\footnote{\url{https://sourceforge.net/projects/nhibernate/}} GitHub issues are responded to sparingly. However, the collection of questions on forums like Stack Overflow has grown large. NHibernate manages to keep up with new .NET versions, targeting Framework, Standard, and .NET 6.

The documentation is published in both \acrshort{pdf} and \acrshort{html} formats. It is comprehensive, offering detailed explanations of numerous concepts. However, many sections are outdated, referencing tools and features that are no longer available. Some areas are undocumented, like the change tracking or mapping by code.

Notable official extensions include the aforementioned FluentNHibernate, {NHibernate.Spatial}\footnote{\url{https://github.com/nhibernate/NHibernate.Spatial}} for working with spatial data and NHibernate-Search\footnote{\url{https://github.com/nhibernate/NHibernate-Search}} for full-text searching. NHibernate Profiler\footnote{\url{https://hibernatingrhinos.com/products/nhprof}} offers query profiling and analysis, but unfortunately, it is a paid unofficial tool. All findings are presented in Table~\ref{tab:comp_nhibernate}.


\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: NHibernate}
\label{tab:comp_nhibernate}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{NHibernate} \\
\midrule
\textbf{Type} & macro \acrshort{orm} for .NET \\
\textbf{License} & GNU Lesser General Public License v2.1 only \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://nhibernate.info/} \newline \url{https://github.com/nhibernate}, \url{https://www.nuget.org/packages/nhibernate} \newline \url{https://sourceforge.net/projects/nhibernate/}  \\
\textbf{Latest version} & 5.5.2 (July 2024) \\
\textbf{Supported .NET} & .NET Framework, Standard, 6 \\
\textbf{\acrshort{orm} features} & Full object and relationship mapping \\
\textbf{Query support} & Extensive \acrshort{linq} support, \acrshort{hql}, Criteria and QueryOver (outdated) \\
\textbf{Mapping} & Attributes, fluent, \acrshort{xml} files \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & No migrations; schema scaffolding from \acrshort{dbms} \\
\textbf{Change tracking} & Supported in transaction scope; undocumented \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Supported \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Not supported \\
\textbf{Async support} & Supported \\
\textbf{Caching} & Application and session level cache \\
\textbf{Community} & Maintained on GitHub; slow response to issues; wide range of questions on forums \\
\textbf{Documentation} & Separate website; \acrshort{html} or \acrshort{pdf}; Not up-to-date\\
\textbf{Extensions (official)} & FluentNHibernate, NHibernate.Spatial, NHibernate-Search  \\
\textbf{Extensions (community)} & None \\
\textbf{Tooling} & Paid profiler \\
\textbf{Supported databases} & \acrshort{mssql}, Oracle, MySQL, PostgreSQL, SQLite and more  \\
\textbf{Ideal use cases} & Complex, legacy applications; Performance with caching; Complex configurability \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}

\subsection{Entity Framework Core}
Entity Framework Core~\cite{efcore, efcoreRepo} is a modern \acrshort{orm} backed by the .NET Foundation, a non-profit organization established by Microsoft. Despite Microsoft's involvement, \acrshort{ef} Core remains community-driven and fully open source. It is a lighter, cross-platform version of the older Entity Framework 6. Release cycle aligns closely with the .NET ecosystem, resulting in simultaneous version releases. For example, \acrshort{ef} Core 9 was launched alongside .NET 9. This guarantees integration with the most modern language features. However, this comes with a notable drawback -- \acrshort{ef} Core always supports only the most recent .NET version, limiting backward compatibility. Notable extensions include EFCoreSecondLevelCacheInterceptor,\footnote{\url{https://github.com/VahidN/EFCoreSecondLevelCacheInterceptor}} which enables application-wide second-level caching, and Microsoft.EntityFrameworkCore.AutoHistory,\footnote{\url{https://github.com/arch/AutoHistory}} which provides automatic storage of audit data for entity changes.

Wide range of database systems is supported including \acrshort{mssql}, MySQL, Oracle, PostgreSQL, SQLite, and Firebird. In-memory database is supported for testing purposes. Due to close relationship with Microsoft, \acrshort{ef} Core integrates tightly with \acrshort{mssql}, supporting even its more specific features. In addition, some non-relational databases are supported, such as Azure Cosmos DB\footnote{\url{https://azure.microsoft.com/en-us/products/cosmos-db}} or MongoDB.\footnote{\url{https://www.mongodb.com/docs/entity-framework/current/}}

\acrshort{ef} Core operates with a \texttt{DbContext} object instead of a session. It represents a \textit{Unit of Work} pattern. It keeps track of all changes to the data, and when the operations are done, it commits everything into the database at once. These changes should usually be related and a part of one business transaction~\cite{FowlerUOW}. The developer actually inherits from the base \texttt{DbContext}, extending it with configuration, mappings, and access points to root entities. One application can contain multiple different \texttt{DbContext}(s) for different business domains. The context takes care of change \textit{tracking} and \textit{per-context caching}. Tracking can be toggled globally or per query; by default, it is enabled. Application-wide caching is not provided by default, but can be added via an extension. To save all changes, the \texttt{SaveChanges} method must be called and all updates will be propagated into the database within a transaction. Transactions can also be controlled manually. Save points can be created at any point, to which the transaction can be rolled back.

Entity mapping can be configured using global conventions, entity attributes, or fluent code. Relationship mapping is fully supported, and \acrshort{ef} Core effectively infers relationships based on navigation properties and primary and foreign keys. In many-to-many relationships, the join table can be explicitly \textit{mapped} or \textit{hidden}. Different fetching strategies are available for relationships. By default, navigation properties are not loaded; \textit{eager} loading requires \texttt{.Include} call in the query. Alternatively, \textit{lazy} loading or explicit (so-called \textit{later on demand}) strategies are configurable. 

Querying is done using \acrshort{linq} with entities accessed through \texttt{DbContext}. Data manipulation methods are provided, data definition operations cannot be run through the framework. Database columns containing \acrshort{json} can be mapped and queried into using \acrshort{linq}. This is supported only for databases with \acrshort{json} query capabilities, namely \acrshort{mssql}, SQLite, and PostgreSQL. Batch operations are supported; bulk operations require extensions such as EFCore.BulkExtensions.\footnote{\url{https://github.com/borisdj/EFCore.BulkExtensions}} Asynchronous method variants are provided, but parallel operations cannot be done within one context.

\begin{example}
\small
The following example from \acrshort{ef} Core's documentation\footnote{\url{https://learn.microsoft.com/en-us/ef/core/modeling/\#use-fluent-api-to-configure-a-model}} demonstrates a simple model created through \texttt{DbContext}. One entity, \texttt{Blog}, is accessible through an exposed property and configured to have a required \acrshort{url}.
\qed

\begin{lstlisting}[language=CSharp]
internal class MyContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Blog>()
            .Property(b => b.Url)
            .IsRequired();
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
}
\end{lstlisting}
\end{example}

Database schema can be generated entirely from entities and is a recommended way to handle smaller applications. Subsequent changes can be handled with generated migrations. Migrations are generated through \acrshort{cli}. All changes to the schema are compared to the base migration and new statically typed C\# code is generated, which can be further edited and stored in source control. This allows not only upgrading to newer versions but also downgrading. Database first schema is also supported. And entities with mapping can be generated from an existing database. This process can be destructive unless partial classes are used. It is not recommended to be automated. Initial core data can be filled into the database using data seeding. That can be useful for necessary application data or enumerations.

\acrshort{ef} Core is highly extensible, benefiting from numerous community tools and extensions. One notable example is \acrshort{ef} Core Power Tools,\footnote{\url{https://marketplace.visualstudio.com/items?itemName=ErikEJ.EFCorePowerTools}} a Visual Studio\footnote{\url{https://visualstudio.microsoft.com/}} extension that allows reverse-engineering databases, generating \texttt{DbContext} classes, and visualizing entity diagrams. \acrshort{ef} Core integrates well with MiniProfiler,\footnote{\url{https://miniprofiler.com/}} a free profiling tool useful for performance diagnostics. Multiple paid profiling solutions exist as well, though their use is often unnecessary since \acrshort{ef} Core integrates effectively with the Visual Studio debugger, providing insight into executed \acrshort{sql} statements and other runtime details.


The \acrshort{orm} is distributed under the MIT license\footnote{\url{https://github.com/dotnet/efcore/blob/main/LICENSE.txt}} via GitHub \footnote{\url{https://github.com/dotnet/efcore}} and NuGet.\footnote{\url{https://www.nuget.org/packages/microsoft.entityframeworkcore}} The latest stable version, 9.0.6, was released in June 2025. With over 1.56 billion total downloads and 446 million in the past year alone,\footnote{\url{https://nugettrends.com/packages?months=72&ids=Microsoft.EntityFrameworkCore}} it stands as the most widely used .NET \acrshort{orm} framework. New releases are published frequently, typically on a monthly basis. It is being very actively developed with thousands of GitHub issues which receive relatively quick responses. Extensive documentation is provided on the Microsoft Learn site.\footnote{\url{https://learn.microsoft.com/en-gb/ef/core/}} The findings are summarized in Table~\ref{tab:comp_efcore}.

\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: Entity Framework Core}
\label{tab:comp_efcore}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{Entity Framework Core} \\
\midrule
\textbf{Type} & macro \acrshort{orm} for .NET \\
\textbf{License} & MIT \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://learn.microsoft.com/en-gb/ef/core/} \newline \url{https://github.com/dotnet/efcore} \newline \url{https://www.nuget.org/packages/microsoft.entityframeworkcore}  \\
\textbf{Latest version} & 9.0.6 (June 2025) \\
\textbf{Supported .NET} & the latest .NET version only \\
\textbf{\acrshort{orm} features} & Full object and relationship mapping \\
\textbf{Query support} & \acrshort{linq} support \\
\textbf{Mapping} & Attributes, fluent code \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & Migrations project schema to \acrshort{dbms}; Scaffolding from \acrshort{dbms};\\
\textbf{Change tracking} & Supported \\
\textbf{Data seeding} & Supported \\
\textbf{Query logging} & Supported \\
\textbf{Transactions} & Supported; save points \\
\textbf{Bulk operations} & Free extension required \\
\textbf{Async support} & Supported \\
\textbf{Caching} & Session (\texttt{DBContext}) level cache; Application-wide with extension \\
\textbf{Community} & Active development; Github Issues with quick response time \\
\textbf{Documentation} & Microsoft Learn website\\
\textbf{Extensions (official)} & None \\
\textbf{Extensions (community)} & EFCore.BulkExtensions, EFCoreSecondLevelCacheInterceptor, Microsoft.EntityFrameworkCore.AutoHistory \\
\textbf{Tooling} & \acrshort{ef} Core Power Tools, MiniProfiler intergration \\
\textbf{Supported databases} & \acrshort{mssql}, MySQL, Oracle, PostgreSQL, SQLite, and Firebird, Azure Cosmos DB, MongoDB, and more  \\
\textbf{Ideal use cases} & Modern applications of any size; Performance optimized; Complex \acrshort{linq} queries \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}

\subsection{Entity Framework 6}
Entity Framework 6~\cite{ef6,ef6Repo} is a stable \acrshort{orm} developed by Microsoft with a long history. While it continues to receive security updates, no new features are being added. Since \acrshort{ef} Core builds upon \acrshort{ef}6, only notable differences are highlighted and all properties are summarized in Table~\ref{tab:comp_ef6}.

\acrshort{ef}6 is available under the MIT license\footnote{\url{https://github.com/dotnet/ef6/blob/main/LICENSE.txt}} and distributed via GitHub\footnote{\url{https://github.com/dotnet/ef6}} and NuGet.\footnote{\url{https://www.nuget.org/packages/EntityFramework/}} In earlier versions, it was directly integrated into the .NET standard library. Over its lifespan, it has accumulated over 336 million downloads, with 60 million in the past year alone.\footnote{\url{https://nugettrends.com/packages?months=72&ids=EntityFramework}} With the third highest download count, it indicates significant usage in legacy projects.

Unlike \acrshort{ef} Core, \acrshort{ef}6 targets all versions of .NET including Framework, Standard, and .NET 6. Its most recent version, 6.5.1, was released in June 2024, while major version 6 itself dates back to 2013. Extensive documentation is available, including the official Microsoft Learn \footnote{\url{https://learn.microsoft.com/en-gb/ef/ef6/}} site, thousands of Stack Overflow questions, and discussions across various forums.

Configuration in \acrshort{ef}6 can be done either through code or \acrshort{xml} files. Mapping and querying principles remain similar to \acrshort{ef} Core, only the support is not as extensive. For instance, it does not support mapping non-nullable reference types, nor does it allow querying \acrshort{json} or \acrshort{xml} data.
The database schema can be defined directly in the code and projected to the database using migrations. A distinguishing feature compared to \acrshort{ef} Core is the presence of a visual schema designer.\footnote{\url{https://learn.microsoft.com/en-us/ef/ef6/modeling/designer/relationships}} Transactions are supported, but without save points. 

\acrshort{ef}6 defaults to \textit{lazy loading}, unlike \acrshort{ef} Core, which defaults to \textit{eager loading}. While asynchronous methods are available, their coverage is incomplete. Additionally, unofficial paid tools such as Entity Framework Profiler\footnote{\url{https://entityframework-extensions.net/ef-profiler}} and the Z.EntityFramework.Extensions\footnote{\url{https://entityframework-extensions.net/}} for bulk operations extend its functionality.

\afterpage{
\begin{landscape}
\begin{table}[p]
\scriptsize
\def\arraystretch{1.45}
\centering
\caption{Comparison overview of \acrshort{orm} framework: Entity Framework 6}
\label{tab:comp_ef6}
\begin{tabular}{
>{\raggedright\arraybackslash}p{40.00mm}
>{\arraybackslash}p{150.00mm}
}
\toprule
\textbf{Property} & \textbf{Entity Framework 6} \\
\midrule
\textbf{Type} & macro \acrshort{orm} for .NET \\
\textbf{License} & MIT \\
\textbf{Cost} & Free \\
\textbf{Sources} & \url{https://learn.microsoft.com/en-gb/ef/ef6/} \newline \url{https://github.com/dotnet/ef6} \newline \url{https://www.nuget.org/packages/EntityFramework/}  \\
\textbf{Latest version} & 6.5.1 (June 2024) \\
\textbf{Supported .NET} & .NET Framework, .NET Standard, .NET 6 \\
\textbf{\acrshort{orm} features} & Full object and relationship mapping \\
\textbf{Query support} & \acrshort{linq} support \\
\textbf{Mapping} & Attributes, fluent code \\
\textbf{Relationship mapping} & All types supported \\
\textbf{Schema handling} & Migrations project schema to \acrshort{dbms}; Scaffolding from \acrshort{dbms}; Visual designer \\
\textbf{Change tracking} & Supported \\
\textbf{Data seeding} & Not supported \\
\textbf{Query logging} & Supported \\
\textbf{Transactions} & Supported \\
\textbf{Bulk operations} & Paid extension required \\
\textbf{Async support} & Supported \\
\textbf{Caching} & Session (\texttt{DBContext}) level cache \\
\textbf{Community} & Development stopped; security patches; available on GitHub \\
\textbf{Documentation} & Microsoft Learn website\\
\textbf{Extensions (official)} & None  \\
\textbf{Extensions (community)} & Paid Z.EntityFramework.Extensions \\
\textbf{Tooling} & Paid profiler \\
\textbf{Supported databases} & \acrshort{mssql}, Oracle, MySQL, PostgreSQL, SQLite and more  \\
\textbf{Ideal use cases} & Complex, legacy applications; Performance with caching; Complex configurability \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
}

% \subsection{Comparison}
% \begin{table}[h]
%   \centering
%   \sisetup{group-separator={,},group-minimum-digits=4}

% \begin{tabular}{l
%                 S[table-format = 10.0, table-number-alignment = right]
%                 S[table-format = 9.0 , table-number-alignment = right]}
%   \toprule
%   ORM & {Total downloads} & {Downloads last year} \\
%   \midrule
%   EF Core     & 1560303230 & 446541915 \\
%   Dapper      & 494249884  & 144500105 \\
%   EF6         & 336032064  & 60867734  \\
%   NHibernate  & 57169419   & 14396223  \\
%   LINQ To DB  & 17360418   & 4907706   \\
%   RepoDB      & 1956923    & 493507    \\
%   PetaPoco    & 1801676    & 609540    \\
%   \bottomrule
% \end{tabular}
% \caption{NuGet download counts, sorted by total downloads. Downloads collected 30 Jun 2024  29 Jun 2025 via NuGet Trends.}
% \end{table}
